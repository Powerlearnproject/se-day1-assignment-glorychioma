[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18812504&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the establishment and use of sound engineering principles, methods, and tools that can be used to produce high quality software that is reliable and works efficiently on real machines.


Identify and describe at least three key milestones in the evolution of software engineering.
1. The Birth of Software Engineering (1968)
   - The term software engineering was first used during the NATO Software Engineering Conference in 1968. This was in response to the "software crisis," where software projects were often over budget, late, and unreliable.
   - This milestone marked the beginning of structured software development practices, emphasizing systematic approaches to design, development, and maintenance.

2. The Rise of Object-Oriented Programming (1970s-1980s)
   - Object-Oriented Programming (OOP) emerged, with languages like Smalltalk (1972) and later C++ (1983), promoting encapsulation, inheritance, and modular design.
   - OOP made software more reusable, scalable, and maintainable, influencing modern development frameworks.

3. The Agile Revolution (2001)
   - In response to the limitations of heavyweight, document-driven methodologies like Waterfall, the Agile Manifesto was introduced in 2001.
   - Agile methodologies (e.g., Scrum, Kanban) focus on iterative development, flexibility, customer collaboration, and rapid delivery.
   - This shift transformed software engineering by improving adaptability to changing requirements and fostering continuous improvement.

List and briefly explain the phases of the Software Development Life Cycle.
1. User's needs and expectations: This refers to a user's want or need about a software product.
2. Problem statement: The problem based on the user's want or need is analysed and developed.
4. Detailed design: The developed problem statement is designed.
5. Software product: The design format will be implemented as a software product.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Waterfall: A linear, sequential approach where each phase (requirements, design, implementation, testing, deployment, and maintenance) must be completed before moving to the next.
Agile: An iterative and flexible approach where work is done in short cycles (sprints), allowing continuous feedback and adaptation.

When to Use Waterfall
Large, Well-Defined Projects
Example: Building a Bridge or a Hospital
Reason: The requirements are clear, and changes are costly once construction starts.

Regulated Industries
Example: Pharmaceutical Drug Development
Reason: Regulatory approval processes require strict documentation and adherence to sequential processes.

Software with Fixed Requirements
Example: Banking Software Compliance Systems
Reason: Compliance-driven systems require detailed documentation and minimal changes.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

1. Software developer: This is a person whose expertise is to build or develop the project using software tools
2. Quality assurance engineer: This is the person in charge of the overall quality of the team's project work, ensuring it is of high quality and meets standards.
3. Project manager: This person is in charge of the team's project, deciding on the project the team's going to building.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

1. Integrated Development Environments (IDEs)
An Integrated Development Environment (IDE) is a software application that provides a comprehensive set of tools to assist developers in writing, debugging, and managing code.  

Importance of IDEs:  
Increases Productivity – Combines essential tools (editor, compiler, debugger) in one place.  
Code Assistance & Auto-Completion – Reduces errors and speeds up coding.  
Debugging & Testing Features – Helps find and fix bugs easily.  
Integration with VCS & Frameworks – Streamlines collaboration and deployment.  

Examples of IDEs:  
Visual Studio Code (VS Code) – Lightweight, extensible, supports multiple languages.  
JetBrains IntelliJ IDEA – Popular for Java development.  
Eclipse – Widely used for Java, C++, and Python.  
PyCharm – Specialized for Python development.
Atom

2. Version Control Systems (VCS)
A Version Control System (VCS) tracks changes in code, allowing multiple developers to work together while maintaining a history of modifications.  

Importance of VCS:  
Collaboration & Teamwork– Developers can work simultaneously on different features.  
Tracking Changes & Rollbacks – Allows reverting to previous versions if needed.  
Branching & Merging – Enables working on new features without affecting the main codebase.  
Backup & Recovery – Prevents accidental loss of code.  

Examples of VCS: 
Git – The most widely used, supports distributed version control (e.g., GitHub, GitLab, Bitbucket).  
Apache Subversion (SVN) – Centralized version control system used in enterprise environments.  
Mercurial – Another distributed VCS, similar to Git but designed for simplicity.  

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Bugging challenges: Software engineerers can systematically overcome bugging challenge by using bugging tools on their IDE, such as breakpoint on VS code, understand and breakdown error message, check for common errors and re-run their code frequently.
Lack of self-confidence: SE should develop confidence in their skills and be open to learn from their mistakes.
Keeping up with fast changing technologies: SE should be adaptable to changes in new technologies, it part of learning process.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

1. Unit Testing 
Definition:  
- Tests individual components (e.g., functions, classes, or modules).  
- Usually written by developers using testing frameworks like JUnit (Java), PyTest (Python), or Jest (JavaScript).  

Importance:  
- Detects bugs early, reducing overall debugging time.  
- Ensures that each part of the software functions correctly in isolation.  
- Improves code maintainability and refactoring confidence.  


2. Integration Testing 
- Tests how different modules or components interact with each other.  
- Ensures that integrated components work together as expected.  

Importance:
- Identifies issues in data flow and API communication.  
- Ensures proper interaction between modules, databases, and external systems.  
- Prevents failures due to incompatible components.  
  Example: Testing the connection between a frontend login page and a backend authentication system.  

3. System Testing
   - Tests the entire application as a whole after all components are integrated.  
   - Conducted in an environment similar to production.  

Importance:  
- Ensures the software meets business and functional requirements.  
- Helps find issues related to performance, security, and scalability.  
- Simulates real-world usage to uncover unexpected behavior.  
  Example: Running the entire e-commerce platform to check if cart, payment, and order processing work together.  

4. Acceptance Testing 
- The final stage before deployment, where end-users or clients validate the software.

Importance:  
- Confirms that the software meets customer needs.  
- Detects usability issues before release.  
- Determines whether the software is ready for production.  
Example: A client testing a *new HR management system* before company-wide deployment.  


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is act of crafting statements, request or asks to communicate with an AI model.

Importance
Enhances AI performance – Well-structured prompts produce more precise and useful results.
Reduces ambiguity – Helps AI understand the context better.
Improves efficiency – Saves time by reducing back-and-forth clarifications.
Customizes responses – Allows users to control AI behavior for specific tasks to get personalized answers.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
